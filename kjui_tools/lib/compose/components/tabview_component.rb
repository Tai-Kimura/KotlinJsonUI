# frozen_string_literal: true

require_relative '../helpers/modifier_builder'
require_relative '../helpers/resource_resolver'

module KjuiTools
  module Compose
    module Components
      class TabviewComponent
        def self.generate(json_data, depth, required_imports = nil, parent_type = nil)
          # TabView maps to TabRow with Tab items in Compose
          required_imports&.add(:tab_row)
          required_imports&.add(:remember_state)
          
          # Generate state variable for selected tab
          state_var = "selectedTab_#{Time.now.to_i}_#{rand(1000)}"
          
          code = indent("// Tab view with content", depth)
          code += "\n" + indent("var #{state_var} by remember { mutableStateOf(0) }", depth)
          code += "\n\n" + indent("Column(", depth)
          
          # Column modifiers
          modifiers = []
          modifiers.concat(Helpers::ModifierBuilder.build_size(json_data))
          modifiers.concat(Helpers::ModifierBuilder.build_padding(json_data))
          modifiers.concat(Helpers::ModifierBuilder.build_margins(json_data))
          
          code += Helpers::ModifierBuilder.format(modifiers, depth)
          code += "\n" + indent(") {", depth)
          
          # TabRow
          code += "\n" + indent("TabRow(", depth + 1)
          code += "\n" + indent("selectedTabIndex = #{state_var},", depth + 2)
          
          # TabRow modifiers
          tab_modifiers = []
          if json_data['backgroundColor']
            tab_modifiers << ".background(Helpers::ResourceResolver.process_color('#{json_data['backgroundColor']}', required_imports))"
          end
          
          if tab_modifiers.any?
            code += "\n" + indent("modifier = Modifier", depth + 2)
            tab_modifiers.each do |mod|
              code += "\n" + indent(mod, depth + 3)
            end
            code += ","
          end
          
          code += "\n" + indent(") {", depth + 1)
          
          # Generate tabs from items
          if json_data['items'] && json_data['items'].is_a?(Array)
            json_data['items'].each_with_index do |item, index|
              title = item['title'] || "Tab #{index + 1}"
              code += "\n" + indent("Tab(", depth + 2)
              code += "\n" + indent("selected = #{state_var} == #{index},", depth + 3)
              code += "\n" + indent("onClick = { #{state_var} = #{index} },", depth + 3)
              code += "\n" + indent("text = { Text(\"#{title}\") }", depth + 3)
              code += "\n" + indent(")", depth + 2)
            end
          end
          
          code += "\n" + indent("}", depth + 1)
          
          # Tab content using when expression
          if json_data['items'] && json_data['items'].is_a?(Array)
            code += "\n\n" + indent("// Tab content", depth + 1)
            code += "\n" + indent("when (#{state_var}) {", depth + 1)
            
            json_data['items'].each_with_index do |item, index|
              code += "\n" + indent("#{index} -> {", depth + 2)
              
              # Content for each tab
              if item['child']
                code += "\n" + indent("// Content for tab #{index}", depth + 3)
                # Note: Actual child content would be generated by the parent
              else
                code += "\n" + indent("Text(\"Content for #{item['title'] || "Tab #{index + 1}"}\")", depth + 3)
              end
              
              code += "\n" + indent("}", depth + 2)
            end
            
            code += "\n" + indent("}", depth + 1)
          end
          
          code += "\n" + indent("}", depth)
          code
        end
        
        private
        
        def self.indent(text, level)
          return text if level == 0
          spaces = '    ' * level
          text.split("\n").map { |line| 
            line.empty? ? line : spaces + line 
          }.join("\n")
        end
      end
    end
  end
end